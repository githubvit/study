协程及io多路复用


一，背景知识：

    1 概念说明

        在进行解释之前，首先要说明几个概念：
        - 用户空间和内核空间
        - 进程切换
        - 进程的阻塞
        - 文件描述符
        - 缓存 I/O


        1.1用户空间与内核空间

            现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。
            操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。
            为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。
            针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，
            而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。

        1.2进程切换

            为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。
            因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。

            从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：
            1. 保存处理机上下文，包括程序计数器和其他寄存器。
            2. 更新PCB信息。
            3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。
            4. 选择另一个进程执行，并更新其PCB。
            5. 更新内存管理的数据结构。
            6. 恢复处理机上下文。

            总而言之就是很耗资源，具体的可以参考这篇文章：进程切换

            注：进程控制块（Processing Control Block），是操作系统核心中一种数据结构，主要表示进程状态。
            其作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位或与其它进程并发执行的进程。
            或者说，OS是根据PCB来对并发执行的进程进行控制和管理的。
            PCB通常是系统内存占用区中的一个连续存区，它存放着操作系统用于描述进程情况及控制进程运行所需的全部信息

        1.3进程的阻塞

            正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，
            则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。
            可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。
            当进程进入阻塞状态，是不占用CPU资源的。

        1.4文件描述符fd

            文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。

            文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。
            当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。
            在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。
            但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。

        1.5缓存 I/O

            缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，
            操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，
            然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。

            缓存 I/O 的缺点：数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的内存开销是非常大的。



二，协程
    1，  协程是寄生在单线程上的多并发，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显

    2，  协程的多并发本质是单线程，不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，
        只需要判断状态就好了，所以执行效率比多线程高很多。。

    3，  协程的实现原理：

        3.1 我们知道，计算机的CPU是很快的，瓶颈在io读写，程序在io操作时就会等待（进程阻塞）从而变慢。当进程进入阻塞状态，是不占用CPU资源的。
            如果我们让程序在CPU操作时正常进行，碰到io操作时就交给内核去管理，切换到另外的程序代码上，如此不停的在代码间切换进行，
            那么整个程序的运行效率就会很高。

        3.2 那你要问了，程序碰到io操作就切出去了，怎么切啊？io操作由谁负责？程序什么时候切回来啊？
            对，一连三问，问的好。

            3.2.1先回答io操作由谁负责？

                 3.2.1.1计算机io的具体操作是由操作系统调用相关硬盘、内存、网卡等io硬件完成的，不需要CPU操作。

                 3.2.1.2操作系统对io的操作：

                    操作系统把内存分为内核空间和用户空间，当数据在内核空间时，称为内核态，在用户空间时，称为用户态。
                    当程序读一个数据时，要通知操作系统，操作系统先要把数据读到内核空间，然后通知该程序，由该程序把数据取到自己的用户空间，
                    再由程序使用。这个过程CPU不参与。

            3.2.2再说怎么切出去，又在什么时候切回来。

                我们知道，单核CPU多线程操作就是时分复用的方式，是一种切换运行的模式，只不过是要在cpu的寄存器上记录线程的上下文。
                这是一种硬实现的方式。

                3.2.2.1采用事件驱动编程范式实现单线程多并发
                    我们先建立一个事件队列，把每一次io操作都做为一个事件Event，
                    在事件Event里定义回调函数callback（io操作完成后交给谁及上下文），
                    然后把该事件放入事件队列，这时程序就可以不管了，该干嘛干嘛。

                    再搞一个事件队列的轮询机制，这个轮询机制不停在事件队列里循环，
                    当有io事件放入时，就通知操作系统进行io操作，
                    当io操作完成时，又通知事件里定义好的回调函数，来处理数据。

                    这样事件源（定义好回调函数）、事件队列、轮询函数这种编程范式，就是事件驱动编程范式，高效完成多个任务的并发。

            这就回答了，在io操作发生时，把io操作交给操作系统，切出去，操作系统处理完了又可以切回来（回调函数）。这样就完成了协程。实现单线程下
        的多并发。

    4，什么样的代码可以称为协程：
        4.1 必须在只有一个单线程里实现并发
        4.2 修改共享数据不需加锁
        4.3 用户程序里自己保存多个控制流的上下文栈
        4.4 一个协程遇到IO操作自动切换到其它协程

三，IO模式
    1，两个阶段
        对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。
        所以说，当一个read操作发生时，它会经历两个阶段：
            1.1 等待数据准备 (Waiting for the data to be ready)
            1.2 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)

    2，五种网络模式
        正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。
        - 阻塞 I/O（blocking IO）
        - 非阻塞 I/O（nonblocking IO）
        - I/O 多路复用（ IO multiplexing）
        - 信号驱动 I/O（ signal driven IO）
        - 异步 I/O（asynchronous IO）

        注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。

        2.1 阻塞 I/O（blocking IO）
            在linux中，默认情况下所有的socket都是blocking，
            在等待数据准备阶段和将数据从内核拷贝到进程中这两个阶段都等待，就是阻塞，都被block了。

        2.2 非阻塞 I/O（nonblocking IO）
            linux下，可以通过设置socket使其变为non-blocking。
            nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。
            在等待数据准备阶段不阻塞，在将数据从内核拷贝到进程中这个阶段阻塞。

        2.3 I/O 多路复用（ IO multiplexing）
            I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，
            而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就立即返回。
            但是，select()函数并不知道是哪个返回，需要整个循环才知道是哪个返回。
            两个阶段都是阻塞的。

        2.4 异步 I/O（asynchronous IO）
            用户进程发起read操作之后，立刻就可以开始去做其它的事。
            而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。
            然后，kernel会等待数据准备完成，并将数据拷贝到用户内存，
            当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。
            两个阶段都不阻塞。
            异步io在py3中的模块——import asyncio，py2.x都没有异步模块。

四，Io编程

    1，由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。

    2，IO在计算机中指Input/Output，也就是输入和输出。
        比如你打开浏览器，访问新浪首页，浏览器这个程序就需要通过网络IO获取新浪的网页。
        浏览器首先会发送数据给新浪服务器，告诉它我想要首页的HTML，这个动作是往外发数据，叫Output，
        随后新浪服务器把网页发过来，这个动作是从外面接收数据，叫Input。
        所以，通常，程序完成IO操作会有Input和Output两个数据流。当然也有只用一个的情况，比如，从磁盘读取文件到内存，就只有Input操作，
        反过来，把数据写到磁盘文件里，就只是一个Output操作。

    3，IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。
        Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。
        对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。

    4，由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。
        举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？
        有两种办法：
        第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；

        另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。

        同步和异步的区别就在于是否等待IO执行的结果。
        好比你去麦当劳点餐，你说“来个汉堡”，服务员告诉你，对不起，汉堡要现做，需要等5分钟，
        于是你站在收银台前面等了5分钟，拿到汉堡再去逛商场，这是同步IO。

        你说“来个汉堡”，服务员告诉你，汉堡需要等5分钟，你可以先去逛商场，等做好了，我们再通知你，
        这样你可以立刻去干别的事情（逛商场），这是异步IO。

    5，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。
        想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。
        如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。
        总之，异步IO的复杂度远远高于同步IO。

    6，异步IO模型需要一个消息循环，在消息循环中，主线程不断地重复“读取消息-处理消息”这一过程：
        loop = get_event_loop()
        while True:
            event = loop.get_event()
            process_event(event)

    7，理解同步IO编程范式番外篇
        老张爱喝茶，废话不说，煮开水。
        出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。
        1 老张把水壶放到火上，立等水开。（同步阻塞）
        老张觉得自己有点傻
        2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）
        老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。
        3 老张把响水壶放到火上，立等水开。（异步阻塞）
        老张觉得这样傻等意义不大
        4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）
        老张觉得自己聪明了。

        所谓同步异步，只是对于水壶而言。
        普通水壶，同步；响水壶，异步。
        虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。
        同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。

        所谓阻塞非阻塞，仅仅对于老张而言。
        立等的老张，阻塞；看电视的老张，非阻塞。
        情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。
        虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。
        所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。

四，I/O 多路复用之select、poll、epoll详解

    1，select

        它通过一个select()系统调用来监视多个文件描述符的数组，
        当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，
        使得进程可以获得这些文件描述符从而进行后续的读写操作。
        select(rlist, wlist, xlist, timeout=None)

        select 函数监视的文件描述符分3类，分别是readfds、writefds、和exceptfds。
        调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），
        或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。
        当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。

        select目前几乎在所有的平台上支持，其良好跨平台支持是它的一个优点。

        select的缺点：
            1/. 在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，
                不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。
                linux可通过修改配置文件(在/etc/security/limits.conf中添加一行)永久修改，
                也可以使用命令 ulimit -SHn 65535将最大限制改为65535。
            2/. 在返回后，通过遍历文件描述符来获取已经就绪的socket。而同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，
                因此随着监视的描述符数量的增长，其效率也会线性下降。


    2，poll
        pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。

    3，epoll
        epoll是在2.6内核中提出的，是之前的select和poll的增强版本。
        相对于select和poll来说，epoll更加灵活，没有描述符限制。
        epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，
        这样在用户空间和内核空间的copy只需一次。