面向对象
"世间万物皆可分类"
“一切皆对象”

一，基本元素

类：共同属性和方法的集合。
    属性：一般指变量名，也叫静态属性。
        类变量：作用域为整个类，在类内存里，所有实例共享这个内存，节省开销。
        实例变量：作用域为单个实例，在每个实例的内存里。
        私有属性：__var，双下划线变量名，只能在类内部使用，子类也不能使用，用来封装。

    方法：一般指函数，也叫动态属性。
        构造方法：初始化实例

        析构函数：实例在销毁或释放时，起作用，不管写或不写，它都存在，
                如果你写了，就覆盖了默认的析构函数，执行你规定的动作。
                通常用来做一些扫尾工作，比如关闭数据库连接、打开的临时文件等
                执行del 实例，就会执行析构函数。

        私有方法：def __var()，只能在类内部被调用。子类也不能调用。用来封装。

        静态方法：
            @staticmethod，只是名义上归类管理，实际上在静态方法里访问不了类或实例中的任何属性。
            用来实现多态。
        类方法：
            @classmethod只能访问类变量，不能访问实例变量
        属性方法：
            @property 把一个方法变成一个静态属性
            @属性方法名.setter 给属性方法定义key，然后在方法中使用key，调用时可以赋值
            不能像删除普通静态属性一样删除属性方法，只能用@属性方法名.deleter实现del.var删除变量，
            实现属性方法调用该变量时报错而无法调用。



对象：实例化一个类的具象，又称为一个类的实例。



二，特性
封装
    把一些功能的实现细节不对外暴露，私有属性和私有方法就可以进行封装。
继承
    实现代码的重用
    单继承
    多继承：
        从左至右，只初始化一次。初始化顺序如下：
            2.7经典类，深度优先。新式类，广度优先。
            3.x均是广度优先
        子类中扩展父类构造方法中继承父类构造方法格式：
               super(本类名，self).__init__(父类构造方法参数)
    组合
        没有父子关系
        在类中传入另一个类的实例化对象，实现两个类的关联。
        以组合的形式实现了代码的重用。
多态
    接口重用。一种接口，多种实现。

三，反射
1，场景：动态输入字符串，匹配相应的属性或方法。
定义一个类
class Dog(object):....
实例化该类
d=Dog()
让用户输入想调用的属性或方法
chioce=raw_input('>>:').strip()
然后调用用户输入来实现
d.chioce
这种调用是无效的，因为chioce是str
------------------------------
2，通过反射可以实现该需求，因为反射可以映射该字符串在对象中的内存地址
hasattr(obj,str)    True False 判断该obj对象是否有str对应的属性或方法

getattr(obj,str)    =obj.str 调用  得到该obj对象的str字符串的内存地址。
                    如果是方法，就可以加（）调用
                    getattr(obj,str)（）= obj.str（）


setattr(obj,str,value)  为obj对象增加名字为str字符串的属性或方法，其值为value。
                        相当于 obj.str=value。
                        如果value是方法，要事先定义好，value=函数名。
                        因为该方法属于自身 func（self），所以，调用方法要把obj自己做为self参数传进去。
                           getattr(obj,str)(obj)就相当于obj.str(obj)

delattr(obj,str)    删除obj对象的str属性或方法，相当于 del obj.str。

四，接口、抽象类

1，接口：约束子类
 接口类只有方法名
class Iointerface()；
    def fuc1():
        pass 只是个方法名
    def fuc2():
        pass
    def fuc3():
        pass


使用接口：
class U1(Iointerface):
    def fuc1():
        ...这里就必须写实
    def fuc2():
        ...
    def fuc3():
        ...
但这样无法约束，如果子类不写，还是可以调用父类的方法名，于是
改造接口
class Iointerface()；
    def fuc1():
        raise Exception('错误了。。。')#主动触发异常
    def fuc2():
        raise Exception('错误了。。。')#主动触发异常
    def fuc3():
        raise Exception('错误了。。。')#主动触发异常

这样如果子类不写，调用父类的方法就会报错，就用不了这个方法了。

2，抽象类，有普通方法（功能）和抽象方法（接口），是普通类和接口的结合，既有功能又有约束。
    如果抽象类都是普通方法，就是普通类，提供功能。
    如果抽象类都是抽象方法，就是接口类，提供约束。
    import abc 引入abc模块


五，依赖注入
