线程和进程

计算机运算（执行指令）是由cpu负责的，

线程是操作系统能进行运算调度的最小单位，它被包含在进程中，是进程中的实际运作单位，是一串指令的集合。

一条线程= 一堆指令 ，是进程中一个单一顺序的控制流，一个进程可以并发多条线程，每条线程并行执行不同的任务。

进程：qq要以一个整体的形式暴露给操作系统管理，里面包含对各种资源的调用，包括内存的管理、网络接口的调用等，
一堆运算相关资源的集合，就可以称为进程。可以认为qq就是一个进程。
一个程序执行的实例就被称为一个进程。每个进程提供程序运行所需要的资源。

进程是不会执行的，只是资源的集合，进程要操作CPU，必须要先创建一个线程，由线程负责操作CPU，
因此说线程是进程的实际运作单位。

多人读书模型，页数、行数、字数。书就是CPU，人就是不同线程。页数、行数、字数就是线程的上下文。


进程中的资源包括内存页（内存空间地址），
这块内存空间包含文件描述符、已经打开的socket连接、安全验证的信息（谁启动的进程）。
同一进程中的所有线程共享同一块内存空间。

一个进程有一个内存里的虚拟地址空间、可执行代码、和操作系统的接口、安全上下文（谁打开的）、唯一的进程标识符Pid、
环境变量、优先级类、最小最大工作内存空间、至少一个可执行的线程。

进程启动就自动启动的线程称为主线程，主线程可以创建子线程，子线程也可创建其它线程。
主线程和子线程没有隶属关系，创建完了，就独立，彼此没有关系，每个线程都是独立的。

启动进程是修屋子，要去跟操作系统申请各种各样的资源；
启动线程是拉一个人过来，就是启动一些指令，因此启动线程比启动进程块。

同一进程中的线程共享数据。

不同进程的内存空间是完全对立的，数据也是完全对立的，哪怕是父子进程。
同一进程中的不同线程可以直接交流。
两个进程想交流，要通过中间代理来实现。

创建新线程很简单，创建新进程要对其父进程进行克隆。

一个线程可以操作同一进程里的其他线程，
进程只能操作子进程。

对一个主线程的修改有可能影响其他线程。
对父进程修改不会影响子进程（只要不把父进程删了就行）。

————————————————————————————

线程调用：并行
    主线程就是程序本身
    1，
    2，
等待：join 改串行

守护线程setDaemon，一定要在start之前设定，是主线程的仆人。
    线程查看：怎么查看主线程？

——————————————————————————————

全局解释器锁GIL:保证同一时刻只有一个线程在执行
互斥锁（也叫线程锁）多个线程同时修改同一个数据时，必须加锁mutex锁。
    threading.Lock：用户自己程序上的锁，保证数据只能被某线程修改。定义锁，获取锁，释放锁。3.x不用了。
     互斥锁把线程变成串行，因此使用该锁要注意：1，马上释放2，运算量不要太大。
递归锁threading.RLock 锁套锁场景

信号量

事件Event 多线程间协调用的，保持同步，
    1,set 2,clear 3,wait 4,is_set
    红绿灯案例
        红绿灯是全局变量-事件对象，
        调节红绿灯是一个线程 set绿灯 clear红灯
        车的跑和等是一个线程 用is_set检查灯是不是绿灯，如果是就跑，否则用wait卡住

队列queue：解耦，使程序直接实现松耦合，提高处理效率。

    有顺序，取走一块就少一块。

    py2.7格式是大写
        import Queue
        q=Queue.Queue()
    py3.x格式是小写
        import queue
        q=queue.Queue()

    1，put放进去 get取出来 qsize查看数量
    2，q=Queue.Queue()先入先出 FIFO first in first out
    3，get()取不到的时候会卡住，等着放进去;这时候用get_nowait()(或者get(block=False))就不会卡住,会出queue.Empty异常。
    4,设q=Queue.Queue(maxsize=3) maxsize最多数量，put到4的时候，还put会卡住。
        用put（timeout=1）放不进会等一秒，就不卡了。
    5，q=Queue.LifoQueue()后入先出 LIFO last in first out
    6，q=Queue.PriorityQueue()优先级，put设置优先级用元组，按元组[0]位置排序，按ASCII码。
            import Queue
            q=Queue.PriorityQueue()
            q.put((10,'d1'))
            q.put((1,'d2'))
            q.put((5,'d3'))

            print q.get()
            print q.get()
            print q.get()

            '''
            运行结果
            (1, 'd2')
            (5, 'd3')
            (10, 'd1')
            '''
    队列经典应用
        生产-消费模型 put-get，注意put的时间和get的时间，不要造成get不到卡住的问题。