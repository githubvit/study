UNⅨ提供了一种机制可以保证父进程可以在任意时刻获取子进程结束时的状态信息：
1、在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。
但是仍然为其保留一定的信息
（包括进程号the process ID，退出状态the termination status of the process，
运行时间the amount of CPU time taken by the process等）

2、直到父进程通过wait / waitpid(给儿子收尸)来取时才释放. 
但这样就导致了问题，如果进程不调用wait / waitpid的话，
那么保留的那段信息就不会释放，其进程号就会一直被占用，
但是系统所能使用的进程号是有限的，
如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 
此即为僵尸进程的危害，应当避免

任何一个子进程(init除外)在exit()之后，并非马上就消失掉，
而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。
这是每个子进程在结束时都要经过的阶段。
如果子进程在exit()之后，父进程没有来得及处理，
这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，
可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。
如果父进程在子进程结束之前退出，则子进程将由init（政府孤儿收容站）接管。
init将会以父进程的身份对僵尸状态的子进程进行处理。