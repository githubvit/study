
用 生成器 和 协程关键字 async/await 实现单线程下的异步 总结：

 本质还是和普通函数实现一样完成如下事请。

一 实现多任务交替

    1 切函数

        比普通函数省事，普通函数要改造while和for，用(lambda:递归)实现 切函数(就是返回每步函数体) 
        这件事，参见1.py。

        生成器和协程async/await都自带暂停和返回每步函数体，天生 就是 切函数。

    2 把函数放进队列

    3 从队列挨个拿出执行
        
        第2件和第3件事与普通函数一样，都是用一个调度对象来实现的。

        调度类都采用了双向队列deque，来收集和取出切出的函数。

        就是定义调度类的run的时候，

            普通函数执行是func(),

                生成器执行即可next又可send，

                    而协程async/await只能用send。

二 实现多任务并发

    和普通函数一样都定义了延时队列sleeping，都是用堆排序heapq按终结时间实现收集和排序。

    都是在调度类的run中按“休息时间相同，就同一休息；休息时间不同，就少的帮多的休息”这个算法实现并发。

    不同之处在于 延时调用:
        
        由于
            普通函数的切函数是自己定义的(lambda:函数体)，
        所以
            普通函数 延时调用 call_later(延时值，lambda:函数体) 要传 每步切函数，
            call_laters才会把 每步切函数 放到 调度对象的延时队列里。

        由于
            生成器和协程都是天生自带切函数（每next或send就会自动更新为下一步切函数）， 
                即自身会自动更新为下一步切函数，
                    因此，只要在调度类的run中next或send完成后，定义一个
                        self.current 接收 更新后的 生成器 或 协程对象 即可。
        所以
            生成器和协程 延时调用 sleep(延时值) 不用传 每步切函数。下一步切函数已经在调度对象内部，
                就是 调度对象的 self.current，所以一个参数即可。

    更进一步：
        生成器和协程的不同：
            在协程中为了优化down和up代码，把延时调用 def sleep() 定义为 协程  async def sleep()。
            就可以把 暂停切换 await switch()  放到 里面去了。          



