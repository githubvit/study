上节课复习：
    1、守护进程
        如果父进程将子进程设置为守护进程，那么在主进程代码运行完毕后守护进程就立即被回收

    2、互斥锁
        用来将并发编程串行，牺牲了效率而保证了数据安全

        互斥锁与jion的区别：
        1、jion是人为地指定顺序，而互斥锁是大家平等争抢，一个人拿到锁，其余人都等待
        2、jion只能将一个进程的代码整体串行，而互斥锁可以将局部串行，局部仅仅代表对共享
        数据修改的那一部分代码

        lock.acquire()
        ....
        lock.release()

        强调：
            1、一定要在操作完毕后释放锁
            2、互斥锁lock.acquire()不能连续执行

    3、IPC：进程间通信
        管道
        队列：管道+锁


    4、生产者消费者模型：
        模型指的是一种解决问题的套路
        该模型下具备两类角色：
            生产者：生产数据
            消费者：处理数据

        该模型的运作方式：
            生产者生产数据，放到一个共享的空间，然后消费者取走进行处理

        该模式的实现方式一：
            生产者进程+队列+消费者进程
                队列中存放的是一些消息

        该模式的应用场景：
            如果程序中有明显的两类任务，一个类任务是负责生产数据，另外 一类是处理数据
            就可以考虑用该模型，具备以下优点

        该模式的优点：
            1、实现生产者与消费者解耦和
            2、平衡了生产者的生产力与消费者的处理数据的能力






今日内容：
    补充：守护进程的应用场景
    多线程
    进程池vs线程池