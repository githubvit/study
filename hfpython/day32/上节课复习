上节课复习：
    1、GIL
        1、什么是GIL
            全局解释器锁，本质就是一把互斥锁，是加到解释器身上的，每一个python进程内都有这么一把锁
		2、有了GIL会对单进程下的多个线程造成什么样的影响
		    多线程要想执行，首先需要争抢GIL，对所有待执行的线程来说，GIL就相当于执行权限，
		    同一时刻只有一个线程争抢成功，即单进程下的多个线程同一时刻只有一个在运行
		    意味着单进程下的多线程没有并行的效果，但是有并发的效果

		    ps:分散于不同进程内的线程不会去争抢同一把GIL，只有同一个进程的多个线程才争抢同一把GIL

		3、为什么要有GIL
		    Cpython解释器的内存管理机制不是线程安全的

		4、GIL与自定义互斥锁的异同，多个线程争抢GIL与自定义互斥锁的过程分析
		    相同：
		        都是互斥锁
		    不同点：
		        GIL是加到解释器上的，作用于全局
		        自定义互斥锁作用于局部

		        单进程内的所有线程都会去抢GIL
		        单进程内的只有一部分线程会去抢自定义的互斥锁


		5、什么时候用python的多线程，什么时候用多进程，为什么？
            单进程下的多个线程是无法并行，无法并行意味着不能利用多核优势

            cpu干的计算的活，多个cpu意味提升了计算性能，
            cpu是无法做IO操作，多个cpu在IO操作面前毫无用处

            当我们的程序是IO密集型的情况下，多核对性能的提升微不足道，此时可以使用python的多线程
            当我们的程序是计算密集型的情况下，一定要用上多核优势，此时可以使用python的多进程



    2、进程池vs线程池
        池：装固定数目的东西，东西指的是进程或者线程
        为什么要用？
            让机器在自己可承受的范围内去保证一个高效的工作


        from concurrent.futures import ProcessPoolExecutor,ThreadPoolExecutor

        pool=ProcessPoolExecutor(4)
        future=pool.submit(task,arg1,args2,....).
        pool.shutdown(wait=True) # shutdown指的是不能再往进程池内提交任务,wait=True等待进程池或线程池内所有的任务都运行完毕

        future.result()


    3、阻塞vs非阻塞 同步vs异步
        阻塞、就绪、运行指的是进程的三种执行状态
            阻塞=》阻塞：遇到io操作
            非阻塞=》就绪、运行

            总结：阻塞与非阻塞指的是程序的执行状态


        同步与异步：指的是提交任务的两种方式
            同步：提交完任务后就在原地等待，直到任务运行完毕，拿到返回值，才继续执行下一行代码
            异步：提交完任务后不在原地等待，直接执行下一行代码，结果？

























今日内容：
    异步调用+回调机制
    线程：Event
    线程：queue

    协程
    IO模型
        阻塞IO
        非阻塞IO
        IO多路复用
        异步IO
